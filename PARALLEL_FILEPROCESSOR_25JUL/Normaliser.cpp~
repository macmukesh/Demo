#include "Normaliser.h"

// FileReadException Code
/*****************************************************************************/
//! Function              : FileReadException
/*! Description           : Parameterized Constructor */
/*! Input Parameters      : Exception message, System message */
/*! Returns               : void */
/*****************************************************************************/
FileReadException::FileReadException(const string &message, bool inclSysMsg) throw() : userMessage(message) 
{
  	if (inclSysMsg) 
	{
		userMessage.append(": ");
		userMessage.append(strerror(errno));
	}
}

/*****************************************************************************/
//! Function              : ~FileReadException
/*! Description           : Destructor	*/
/*! Input Parameters      :		*/
/*! Returns               : void	*/
/*****************************************************************************/
FileReadException::~FileReadException() throw() 
{

}

/*****************************************************************************/
//! Function              : what
/*! Description           : Returns Exception message	*/
/*! Input Parameters      : 		*/
/*! Returns               : char *	*/
/*****************************************************************************/
const char *FileReadException::what() const throw() 
{
	return userMessage.c_str();
}
/*
Normaliser::Normaliser()																											
{
		bEOF=false;
		ileftoverpos=0;
		isizeofLeftover=0;
		iNoOfBlockRead=0;

		// take functon object to be called as parameter
		//FormLongStr=f;
}

Normaliser::~Normaliser()
{


}
*/																											
void Normaliser::Open(char * filenm)
{
		bool bOpenFlg=false;
		iReadPos=0;							// pos counter of file

		fp=fopen(filenm,"r");
		if(fp!=NULL)
		bOpenFlg=true;
		else
		bOpenFlg=false;

		// throw exception if flag is false 
		if(!bOpenFlg)
		{
			string strErrorDesc=string("ERR101:FAIL TO OPEN FILE DESC:")+string(strerror(errno)+string(filenm) );
			throw FileReadException(strErrorDesc,true);
		}

		// load parser detail
		LoadParserDetail();

		memset(acTrimData,0x00,sizeof(acTrimData));
		memset(acTransFormData,0x00,sizeof(acTransFormData));

		// prepare filenm
		string fileName="./Reject.txt";
		// open reject file
		foutReject.open(fileName.c_str() ,ofstream::app);
		if(foutReject.is_open())
		{
		}
		else
		{
				// cannot open reject file ...throw error
				cout<<"FREJ FILENM:"<<fileName<<endl;
				throw runtime_error("ERROR WHILE OPENING REJECT FILE"); 
		}
}

const vector<ArrBufferData> & Normaliser::GetBufferData()
{
		long lBytesRead=0;									// bytes succesful read into buf

		// clear the buffer area
		vecRowData.clear();	

		string strLongStr;
		unsigned int iNoOfLines=0;

		// read next block from file and save it into buf,right after the "left over" buffer
		lBytesRead=fread((char *)acreaddata+isizeofLeftover,1,sizeof(acreaddata)-isizeofLeftover-1, fp);	
		if(feof(fp))
		bEOF=1;
		else if(ferror(fp)){
		// error while reading in bulk from file	
		string strErrorDesc="PAF002:ERROR WHILE BULK READING FROM FILE...";				
		throw FileReadException(strErrorDesc,true);							
		}

		if(lBytesRead<0)
		{
			// some problem with read / end of 
			lBytesRead=0;
		}

		// add null terminator at end of buffer
		acreaddata[lBytesRead+isizeofLeftover] = '\0';

		// form long string newline separated
		ileftoverpos=FormLongStr(acreaddata,lBytesRead+isizeofLeftover,bEOF,strLongStr);
					
		// create array of rawdata...returns no of lines added to buffer
		iNoOfLines=ParseNewLineStr(strLongStr.c_str(),strLongStr.size(),vecRowData);

		// added to detect error while forming txn
		// soze of unprocessed data has to be less than or equal to input array..if greater then error
		if(ileftoverpos>(lBytesRead+isizeofLeftover))	
		{
			//ObjFileInfo.cErrCode='D';		// set proper error code
			// error while reading in bulk from file	
			string strErrorDesc="PAF003:ERROR WHILE FORMING TRANSACTION....";				
			throw FileReadException(strErrorDesc,true);		
		}

		// update read pointer
		iReadPos+=ileftoverpos;
		// read call counter
		++iNoOfBlockRead;
		// bulk read accumulate
		szReadSize+=lBytesRead;		

		// calculate leftover buf size
		// the remaining unprocessed buffer that was not processed by Process	
		isizeofLeftover=lBytesRead+isizeofLeftover-ileftoverpos;	

		// put check oon sizeofleftover
		if(isizeofLeftover<0)
		isizeofLeftover=0;
		else if(isizeofLeftover>(lBytesRead+isizeofLeftover))
		{
				string strErrorDesc="PAF004:NO SPACE LEFT ON BUFFER TO ACCOMODATE NEW LINE...LOGICAL PROBLEM IN IDENTIFYING ROW IN BUFFER";				
				throw FileReadException(strErrorDesc,true);
		}		

    // If we have a leftover unprocessed buffer, move it to the beginning of  
    // read buffer so that when reading the next block, it will connect to the 
    // current leftover and together complete a full readable line
		if(ileftoverpos!=0 && isizeofLeftover!=0) 
		memmove(acreaddata,acreaddata+ileftoverpos,isizeofLeftover);

		// return filled buffer
		return vecRowData;
}

unsigned int ParseNewLineFmt(const char * buf,long sz,bool eof,string & strOutData)
{
	// search for \n from back to find
}

// search for '\n' in string..input will be 
unsigned int Normaliser::ParseNewLineStr(const char * rawdata,unsigned long lBufSz,vector<ArrBufferData> & vecdata)
{
		const char * curr=NULL;
		int isz=0,icnt=0;
		unsigned int currpos=0;

		while(1)
		{
			curr = (char*)memchr(rawdata+currpos, '\n', lBufSz-currpos);

			// if newline not found then break..come out of loop
			if(!curr)
			break;

			isz=curr-(rawdata+currpos);

			// copy till \r
			if( *(curr-1) =='\r')
			isz-=1;
			
			// add to buffer
			AddTxnRow(rawdata+currpos,isz,vecdata);
			++icnt;

			currpos+=curr-(rawdata+currpos);
			++currpos;	// past \n since curr point there
		}

		return icnt;
}

void Normaliser::AddTxnRow(const char * data,const unsigned int irowsz,vector<ArrBufferData> & vecData)
{

	if(!irowsz)
	{
		// some problem with data..bypass such data
		return;
	}
	else if(irowsz>sizeof(ObjRowData.acRawdata))
	{
			// raise error for buffer overflow..some logical problem...throw exception here
			string strErrorDesc="PAF001:ROWSZ:"+toString(irowsz)+" IS GREATER THAN MAX LENGTH:"+toString(MAX_RAWDATA_LEN);
			throw FileReadException(strErrorDesc,true);
	}

	// prepare input
	const char * locdata=data;
	ObjRowData.iRowSz=irowsz;
	// purify input data 
	PurifyAndStoreRow(locdata,ObjRowData.acRawdata,ObjRowData.iRowSz);

	// rowdata is ready to get add in buffer
	vecData.push_back(ObjRowData);
	// reset class var
	ResetRow(ObjRowData);
}

void Normaliser::PurifyAndStoreRow(const char * src,char * dest,unsigned short & isrclen)
{
		int ipos=isrclen+1;
		const char * s=src;
		int ichar=0;
		while((--ipos)>0)	
		{
				ichar=(int)(*s);
				if( (ichar<32) || ichar>126 )
				{
					// bypass curr char..do not store it into out
					*s++;
					// reduce size by 1 for removing each char
					--isrclen;
					continue;
				}


				*dest++=*s++;	
		}

		// append null char at end after removing char
		if(!ipos)
		*dest='\0';
}

void Normaliser::ResetRow(ArrBufferData & objdata)
{
	memset(objdata.acRawdata,0x00,sizeof(objdata.acRawdata));
	objdata.iRowSz=0;
}

void Normaliser::Close()
{
		if(fp!=NULL)
		fclose(fp);

		fp=NULL;
}		

bool Normaliser::ParseDataIntoStruct(char * data,const size_t rawsize,const unsigned int pcd,Model & ObjOut,stringstream & errdesc)
{
		int errcd=0;
		FC * ptrFC=NULL;
		// set pointer as per parsercd
		PC * ptrPC=&vecParserFormat[pcd];
		StructTTUB::TTCOL  colid;
		unsigned int iOutSz=0;
		int iErrCd=0;			// default success
		int iErrVal=0;		// hold value of err returned by ttmodel
		char * ptrSrc=NULL;		// point to valid array: trimdata/transformeddata

		// enter loop to start parsing data		
		for(int ix=0;ix<ptrPC->iNoOfFields;++ix)		
		{
				// skip in case of no output
				if(!ptrPC->vecFC[ix].iOutColId)
				continue;

				// go for parsing
				// fetch field column
				ptrFC=&ptrPC->vecFC[ix];
				// reset outsz to 0
				iOutSz=0;
				// S1:validate data as per format..return false when matching failure
				iErrCd=ValidateData(data,ptrFC->iStart,ptrFC->iNoOfBytes,ptrFC->enFmtVal,acTrimData,iOutSz);
				if(!iErrCd)
				{
					acTransFormData[0]='\0';	
					// S2:check if any decode implementation in derived..
					TransformCol(acTrimData,ptrFC->iOutColId,acTransFormData);
					// if decode implementation is defined then acTransFormData will change from '\0' to some valid char..this wll be output
					ptrSrc=acTrimData;
					if(acTransFormData[0]!='\0')
					{
						// recalculate size of tranformed data
						iOutSz=strlen(acTransFormData);
						ptrSrc=acTransFormData;
					}

					// S3: store in output coldata...return error only when overflow/datatype failure
					iErrCd=ObjOut.SetData(ptrFC->iOutColId,ptrSrc,iOutSz,iErrVal);					
				}
				else
				{
					// matching failure..error code
					iErrCd=3;			
				}
	
				// errcd is 0...means success..go for next col parsing
				if(!iErrCd)
				continue;

				// error handling
				switch(iErrCd)
				{
					case 1:
									// buffer overflow..returned by TTMODEL...iErrVal contain ACTUAL LENGTH OF TTCOL
									errdesc<<ptrPC->strParserNm<<":"<<ptrFC->strElemNm<<":"<<"BUFFER OVERFLOW"<<":"<<iErrVal<<":"<<ptrSrc;
									break;
					case 2:
									// datatype mismatch..returned by TTMODEL...iErrVal contain DATATYPE OF TTCOL
									errdesc<<ptrPC->strParserNm<<":"<<ptrFC->strElemNm<<":"<<"DATATYPE MISMATCH"<<":"<<ObjOut.GetEnumDataTypeName(iErrVal)<<":"<<ptrSrc;
									break;
					case 3:
									// matching failure..returned by self...iErrVal contain FORMATVAL OF PARSERCOLUMN
									errdesc<<ptrPC->strParserNm<<":"<<ptrFC->strElemNm<<":"<<"MATCHING FAILURE"<<":"<<GetEnumFmtValName(ptrFC->enFmtVal)<<":"
									<<GetSrcString(data+ptrFC->iStart,ptrFC->iNoOfBytes);
									break;
				}

				// come out of loop
				return false;
		}//end of loop
		
	return true;
}

/*
Input:rawdata,start,noofbyte,validation ascii,outputmemory,sizeofmemory
*/
bool Normaliser::ValidateData(char * rawdata,const int & iStart,const int & iNoOfBytes,const FMTATTR &ifval,char * destInp,unsigned int & outcnt)
{
		char * dest=destInp;																				// dest pointer
		char * data=rawdata;																				// poit to rawdata
		char * advCurr=NULL;
		int icurr=iStart-1;	// start is always initialised by 1 but array starts from 0

		if(iNoOfBytes!=9999)
		{
				data=rawdata+icurr;							// pointer to start	
				advCurr=data+iNoOfBytes;					// pointer to end
		}else{

		}

		// left trim whitespace
		while( (data!=advCurr) && isspace(*data)!=0 && (++data));	
		
		// trim right whitespace
		while( (data!=advCurr) && isspace(*(advCurr-1))!=0 && (--advCurr) );

		// (--szDest>1) ..her check is for 1 bytes reserved for null char
		// 'A'=alphabet,'B'=numeric,'C'=alphanumeric,'D'=numeric with left trim zero,'Z'=NO CHECK..direct copy
		if(ifval==NO_CHECK)
				while( (data!=advCurr) && (dest[outcnt++]=*data++) );
		else 	if(ifval==ALPHABET)	// 
				while( (isalpha(*data)!=0) && (dest[outcnt++]=*data++) && (data!=advCurr));
		else if(ifval==NUMERIC)
				while( (isdigit(*data)!=0) && (dest[outcnt++]=*data++) && (data!=advCurr));
		else if(ifval==ALPHANUMERIC)// alphanumeric
				while( (isalnum(*data)!=0) && (dest[outcnt++]=*data++) && (data!=advCurr));
		else if(ifval==NUMERIC_LEADING_ZEROES){
				// left trim zeros
				while((*data=='0') && (++data!= advCurr) );
				while( (data!=advCurr) && (isdigit(*data)!=0) && (dest[outcnt++]=*data++));	
		}else if(ifval==HEXADECIMAL){

		}

		// check if data is not equal to end then matching failure 
		if(data!=advCurr)
		return true;

		// append null at end+1
		dest[outcnt]='\0';

		return false;
}

string Normaliser::GetEnumFmtValName(const FMTATTR & enFmt)
{
	switch(enFmt)
	{
		case ALPHABET:
									return string("ALPHABET");
		case NUMERIC:
									return string("NUMERIC");
		case ALPHANUMERIC:
									return string("ALPHANUMERIC");
		case NUMERIC_LEADING_ZEROES:
									return string("NUMERIC_LEADING_ZEROES");
		case HEXADECIMAL:
									return string("HEXADECIMAL");
		default:								
									return string("DEFAULT");
	}
}

string Normaliser::GetSrcString(const char * inp,int sz)
{
	char acOutData[sz+1];
	memcpy(acOutData,inp,sz);
	acOutData[sz+1]='\0';

	return string(acOutData);
}

void Normaliser::LoadParserDetail(int ipcd)
{
	PARSEFMT parseFunc;	// poijter to functor
	int iElemNo=-1;
	unsigned int iNoOfBytes=0;	// local noofbytes
	// FC object
	FC ObjFc;
	ObjFc.iStart=0;	// initialised to 0 as it will be used do not change

	// parsercd
	PC ObjPC;
	ObjPC.iParserCd=(PARSERCD)ipcd;

	switch(ObjPC.iParserCd)
	{
		case DATA1:
								ObjPC.strParserNm="DATA1";
								parseFunc=&SetD1Format;	
								break;
		case DATA2:
								ObjPC.strParserNm="DATA2";
								parseFunc=&SetD2Format;
								break;
		case DATA3:
								ObjPC.strParserNm="DATA3";
								parseFunc=&SetD3Format;
								break;
		case DATA4:
								ObjPC.strParserNm="DATA4";
								parseFunc=&SetD4Format;
								break;
		case DATA5:
								ObjPC.strParserNm="DATA5";
								parseFunc=&SetD5Format;
								break;
		case HDR:
								ObjPC.strParserNm="HDR";
								parseFunc=&SetHdrFormat;
								break;
		case TRL:
								ObjPC.strParserNm="TRL";
								parseFunc=&SetTrlFormat;
								break;
		default:		// default return
								return;
	}

	while(1){

		iNoOfBytes=0;
		// call set field function
		(this->*parseFunc)(++iElemNo,iNoOfBytes,ObjFc.enFmtVal,ObjFc.iOutColId,ObjFc.strElemNm);

		// if noofbytes=0 then come out of loop..FC end
		if(!iNoOfBytes)
		break;

		// put validation on noofbyte..it must not be greater than tempsz allocated 

		if(ObjFc.iStart!=0)
		ObjFc.iStart+=ObjFc.iNoOfBytes;		// calculate start by adding prev row's noofbytes
		else
		ObjFc.iStart=1;		// 1st element start=1

		// update noof bytes
		ObjFc.iNoOfBytes=iNoOfBytes;

		// store output
		ObjPC.vecFC.push_back(ObjFc);
	}
	// update parsercd
	ObjPC.iNoOfFields=ObjPC.vecFC.size();

	// add to vector
	vecParserFormat.push_back(ObjPC);

	// go for recursive call..
	LoadParserDetail(++ipcd);
}

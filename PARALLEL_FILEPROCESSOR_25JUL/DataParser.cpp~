#include "DataParser.h"

DataParser::DataParser()
{
	iFCNo=0;
}

DataParser::~DataParser()
{

}

/*
Parameter Desc:
1: parser code
2: no of byte in input format	...no of byte to be fetched from long string
3: validation flag at column level	...rawdata validation of numeric/alphnumric/hexadecimal
4: column id of struct member...
*/

void DataParser::AddColFormat(const unsigned int iElemNo,const unsigned int iNoOfByte,const unsigned int ValidationFlg,const unsigned int ColId)
{

}

void DataParser::RegisterFormat(PC ObjPC)
{
	vecParserFormat.push_back(ObjPC);
}

/*
Input:
1: rawdata to be parsed
2: size of rawdata
3: parsercd within file..1->hdr,2->trl,3->data
*/
bool DataParser::ParseDataIntoStruct(char * data,size_t rawsize,int pcd,Model & ObjOut)
{
		int errcd=0;
		FC * ptrFC=NULL;
		int parsercd=pcd-1;
		// set pointer as per parsercd
		PC * ptrPC=&vecParserFormat[parsercd];
		ColNm colid;
		// enter loop to start parsing data		
		for(int ix=0;ix<ptrPC->iNoOfFields;++ix)		
		{
				if(!ptrPC->arrFC[ix].iOutColId)
				continue;

				// go for parsing
				// fetch field column
				ptrFC=&ptrPC->arrFC[ix];
				colid=(ColNm)ptrFC->iOutColId;
				errcd=setData(data,ptrFC->iStart,ptrFC->iNoOfBytes,ptrFC->iFieldVal,ObjOut.GetData(colid),ObjOut.GetRowLen(colid));

				if(!errcd)
				continue;
				else
				break;
		}

		cout<<"Parsing ErrorCd:"<<errcd<<endl;

		return true;
}
/*
Input:rawdata,start,noofbyte,validation ascii,outputmemory,sizeofmemory
*/
int DataParser::setData(char * rawdata,const int iStart,const int iNoOfBytes,const int ifval,char * destInp,int szDest)
{
		char * dest=destInp;																				// dest pointer
		char * data=rawdata;																				// poit to rawdata
		char * advCurr=NULL;
		int iErrCode=0;

		if(iNoOfBytes!=9999)
		{
				data=rawdata+iStart;							// pointer to start	
				advCurr=data+iNoOfBytes;					// pointer to end
		}else{

		}

		// left trim whitespace
		while( (data!=advCurr) && isspace(*data)!=0 && (++data));	
		
		// trim right whitespace
		while( (data!=advCurr) && isspace(*(advCurr-1))!=0 && (--advCurr) );

		// (--szDest>1) ..her check is for 1 bytes reserved for null char
		// 'A'=alphabet,'B'=numeric,'C'=alphanumeric,'D'=numeric with left trim zero,'Z'=NO CHECK..direct copy
		if(ifval==90)
				while( (data!=advCurr) && (*dest++=*data++) && (--szDest>1) );
		else 	if(ifval==65)	// 
				while( (isalpha(*data)!=0) && (*dest++=*data++) && (data!=advCurr) && (--szDest>1) );
		else if(ifval==66)
				while( (isdigit(*data)!=0) && (*dest++=*data++) && (data!=advCurr) && (--szDest>1) );
		else if(ifval==67)// alphanumeric
				while( (isalnum(*data)!=0) && (*dest++=*data++) && (data!=advCurr) && (--szDest>1) );
		else if(ifval==68){
				// left trim zeros
				while((*data=='0') && (++data!= advCurr) );
				while( (data!=advCurr) && (isdigit(*data)!=0) && (*dest++ = *data++) && (--szDest>1) );	
		}

		// check if data is equal to 
		if(data!=advCurr)
		{
				// error...full parsing not done..matching failure
				if(szDest!=1)	{

						switch(ifval)
						{
								case 'A':
										iErrCode=NON_ALPHABET;
										break;
								case 'B':
										iErrCode=NON_NUMERIC;
										break;
								case 'C':
										iErrCode=NON_ALPHANUMERIC;
										break;
								case 'D':
										iErrCode=NON_NUMERIC;
										break;
						}

						//cout<<"ERROR WHILE PARSING FIELDNO["<<iFC<<"]"<<" INVALID CHAR["<<(int)(*data)<<"] FOUND.."<<endl;
						//strErrDesc<<"PARSING ERROR FOR FIELDNO:\""<<iFC<<"\" ERRCD:\""<<iErrCode<<"\" INVALID CHAR:\""<<(int)(*data)<<"\" FOUND AT \""<<ptrPC->arrFC[iFC].iStart<<"\" TILL:\""<<ptrPC->arrFC[iFC].iStart+ptrPC->arrFC[iFC].iNoOfBytes<<"\""<<endl;
				}else{
						iErrCode	=	BUFFER_OVERFLOW;
						//cout<<"ERROR WHILE PARSING FIELDNO["<<iFC<<"]"<<" BUFFER OVERFLOW.. PARSESZ["<<ptrPC->arrFC[iFC].iNoOfBytes<<"] DESTSZ["<<ptrPC->arrFC[iFC].iNoOfBytes-(advCurr-data)<<"]"<<endl;
						//strErrDesc<<"PARSING ERROR FOR FIELDNO["<<iFC<<"]"<<" ERRCD:"<<iErrCode<<" PARSESZ["<<ptrPC->arrFC[iFC].iNoOfBytes<<"] DESTSZ["<<ptrPC->arrFC[iFC].iNoOfBytes-(advCurr-data)<<"]"<<endl;
				}

		}

		// append null at end+1
		*dest='\0';

		// return errorcode
		return iErrCode;
}

std::ostream& operator<<(std::ostream& out, const ErrCdList value){
		const char* s = 0;
#define PROCESS_VAL(p) case(p): s = #p; break;
		switch(value){
				PROCESS_VAL(SUCCESS_NORM);     
				PROCESS_VAL(INVALID_RECORD_START);     
				PROCESS_VAL(INVALID_RECORD_TYPE);     
				PROCESS_VAL(INVALID_RECORD_LENGTH);
				PROCESS_VAL(INVALID_FILECD);
				PROCESS_VAL(INVALID_PARSERCD);
				PROCESS_VAL(NON_NUMERIC);
				PROCESS_VAL(NON_ALPHABET);
				PROCESS_VAL(NON_ALPHANUMERIC);
				PROCESS_VAL(BUFFER_OVERFLOW);
				PROCESS_VAL(TEST_TXN);
				PROCESS_VAL(INVALID_CHAR);
		}
#undef PROCESS_VAL

		return out << s;
}


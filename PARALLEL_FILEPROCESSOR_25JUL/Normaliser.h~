#ifndef _Normaliser_H_
#define _Normaliser_H_

#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vector>
#include <errno.h>
#include "StringConv.h"
#include "CommonQueueData.h"

#include "CommonLib.h"
#include "enum_ErrorCode.h"
#include "enum_FieldAttr.h"
#include "enum_ParserCd.h"

/*
ERROR FORMAT DESIGN:
3:matching failure
ELEMNO:TTCOLID:FMT MATCHING FAILURE:FMTVAL:DATA(START,NOOFBYTE)
2:datatype mismatch
ELEMNO:TTCOLID:DATATYPE MISMATCH:DATATYPE:acTrimData/acTransformedData
1:buffer overflow
ELEMNO:TTCOLID:BUFFER OVERFLOW:ACTUAL_LENGTH:acInpData 
*/
# define MAX_RAWDATA_LEN 5121 

typedef struct
{
		short int iStart;
		short int iNoOfBytes;
		FMTATTR enFmtVal;								// A=alphanumeric,B=alphabet,C=numeric
		StructTTUB::TTCOL iOutColId;		// col id of common data struct
		string strElemNm;								// element name ..for writing only
}FC;

typedef struct
{
		string strParserNm;				// name of parser..for writing only
		short int iNoOfFields;		// no of fields
		PARSERCD iParserCd;				// parser code	
		vector<FC> vecFC;					// array of FC 
}PC;

using namespace std;

class FileReadException : public exception
{
	public:
		FileReadException(const string &message, bool inclSysMsg = false) throw();
		~FileReadException() throw();
		const char *what() const throw();

	private:
		string userMessage;
};

template <typename ReaderPolicy, typename ParserPolicy>
class Normaliser:private ReaderPolicy,private ParserPolicy
{
	using ReaderPolicy::ParseFileTyp;
	using ParserPolicy::SetHdrFormat;
	using ParserPolicy::SetTrlFormat;
	using ParserPolicy::SetD1Format;
	using ParserPolicy::SetD2Format;
	using ParserPolicy::SetD3Format;
	using ParserPolicy::SetD4Format;
	using ParserPolicy::SetD5Format;
	using ParserPolicy::ValidateInputRawData;
	using ParserPolicy::IdentifyParserCd;
	using ParserPolicy::TransformCol;

	public:
						Normaliser(){};// constr
						//Normaliser();																												// def constr
						~Normaliser();																											// destr
						void Open(char * );																									// open the file
						void Close();																												// close the file
						inline bool IsEOF(){return bEOF;};
						const vector<ArrBufferData> & GetBufferData();

	private:
						static const unsigned int BLOCKREADSZ=4096;											 		// max buffer size
						char acreaddata[BLOCKREADSZ];																				// rawdata holder
						bool bEOF;
						unsigned int ileftoverpos;																					// pos in buf of unprocessed data
						int isizeofLeftover;																								// size of unprocessed data
						vector<ArrBufferData> vecRowData;																		// buffer of vector
						ArrBufferData ObjRowData;
						FILE * fp;
						ifstream ifs;
						unsigned int iReadPos;																						// byte read position in file
						unsigned int iNoOfBlockRead;																			// no of block read
						size_t szReadSize;																								// total read byte count from file
						unsigned int (*FormLongStr)(const char * ,long ,bool,string & );	// function pointer to parser
						
						void ResetRow(ArrBufferData & );																	// reset rowdata	
						void PurifyAndStoreRow(const char *,char *,unsigned short & );		// purify data
	protected:
						void AddTxnRow(const char * ,unsigned int ,vector<ArrBufferData> &);						// add row in buffer
						unsigned int ParseNewLineStr(const char *,unsigned long,vector<ArrBufferData> & );			// prepare row data

	private:
					vector<PC> vecParserFormat;					// store multiple parsercd	
					typedef void (*PARSEFMT)(const unsigned int,unsigned int &,FMTATTR &,StructTTUB::TTCOL &,string &);
					static const int iMaxTempSz=1048;
					char  acTrimData[iMaxTempSz];
					char  acTransFormData[iMaxTempSz];
					ofstream foutReject;

					void LoadParserDetail(int ipcd=0);
					bool ParseDataIntoStruct(char *,const size_t ,const unsigned int ,Model &,stringstream &);
					bool ValidateData(char * rawdata,const int &,const int &,const FMTATTR &,char*,unsigned int &);
					string GetEnumFmtValName(const FMTATTR &);
					string GetSrcString(const char *,int );

};

#endif
